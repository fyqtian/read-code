### 虚拟内存

http://cyc2018.gitee.io/cs-notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86

https://blog.csdn.net/hailin0716/article/details/18810755

虚拟内存的目的是为了让**物理内存扩充成更大的逻辑内存**，从而让程序获得更多的可用内存。



为了更好的管理内存，操作系统将内存抽象成地址空间。**每个程序拥有自己的地址空间**，这个地址空间被**分割成多个块**，**每一块称为一页**。这些页被**映射到物理内存**，但不需要映射到**连续的物理内存**，也不需要**所有页都必须在物理内存中**。当程序引用到**不在物理内存中的页时**，**由硬件执行必要的映射**，将缺失的部分装入物理内存并重新执行失败的指令。



从上面的描述中可以看出，虚拟内存允许程序**不用将地址空间中的每一页都映射到物理内存**，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。



<img src="/opt/read-code/images/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="7b281b1e-0595-402b-ae35-8c91084c33c1" style="zoom:75%;" />

**分页系统地址映射**

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。

<img src="/opt/read-code/images/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="cf4386a1-58c9-4eca-a17f-e12b1e9770eb" style="zoom:75%;" />



### 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。



<img src="/opt/read-code/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt="22de0538-7c6e-4365-bd3b-8ce3c5900216" style="zoom:75%;" />

分段的做法是把**每个表分成段**，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。



### 段页式

程序的地址空间划分成多个**拥有独立地址空间的段**，**每个段上的地址空间划分成大小相同的页**。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。



### 分页与分段

对程序员的透明性：分页透明，**但是分段需要程序员显式划分每个段**。

地址空间的维度：分页是一维地址空间，分段是二维的

大小是否可以改变：页的大小不可变，段的大小可以动态改变

出现的原因：**分页主要用于实现虚拟内存**，从而获得更大的地址空间；**分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护**