### 零拷贝

https://zhuanlan.zhihu.com/p/85571977

https://blog.csdn.net/weixin_42096901/article/details/103017044

https://blog.csdn.net/caianye/article/details/7576198

https://www.jianshu.com/p/028cf0008ca5

简单一点来说，零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

- 避免操作系统内核缓冲区之间进行数据拷贝操作。
- 避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作。
- 用户应用程序可以避开操作系统直接访问硬件存储。
- 数据传输尽量让 DMA 来做。

DMA：是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。

Linux 中的零拷贝技术主要有下面这几种：

- 直接 I/O
- mmap
- sendfile
- splice

本文主要介绍sendfile这种零拷贝技术..



### 三.sendfile实现零拷贝的原理

**1.描述**
 sendfile系统调用在两个文件描述符之间直接传递数据**(完全在内核中操作**)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。

**2.原理**
 sendfile() 系统调用利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中，然后数据被拷贝到与 socket 相关的内核缓冲区中去。接下来，DMA 引擎将数据从内核 socket 缓冲区中拷贝到协议引擎中去。

sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile() 只是**适用于应用程序地址空间不需要对所访问数据进行处理**的情况。因为 sendfile 传输的数据没有越过用户应用程序 / 操作系统内核的边界线，所以 sendfile () 也极大地减少了存储管理的开销。



简单归纳上述的过程：

- sendfile系统调用利用DMA引擎将文件数据拷贝到内核缓冲区，之后数据被拷贝到内核socket缓冲区中
- DMA引擎将数据从内核socket缓冲区拷贝到协议引擎中

### 五.总结

上述的两种几种I/O操作对比：

**1.传统I/O**
 硬盘—>内核缓冲区—>用户缓冲区—>内核socket缓冲区—>协议引擎

**2.sendfile**
 硬盘—>内核缓冲区—>内核socket缓冲区—>协议引擎

**3.sendfile（ DMA 收集拷贝）**
 硬盘—>内核缓冲区—>协议引擎



**Tips:用户态和内核态切换的代价在哪？**

首先，用户态一个进程，内核态一个进程，切换就要进行进程间的切换。
 拿系统调用举例来说，系统调用一般都需要保存用户程序得上下文(context), 在进入内核得时候需要保存用户态得寄存器，在内核态返回用户态得时候会恢复这些寄存器得内容。这是一个开销的地方。

如果需要在不同用户程序间切换的话，那么还要更新cr3寄存器，这样会更换每个程序的虚拟内存到物理内存映射表的地址，也是一个比较高负担的操作。

而且内核代码对用户不信任，需要进行额外的检查。系统调用的返回过程有很多额外工作，比如检查是否需要调度等。







所谓的零拷贝（Zero-Copy）是指**将数据直接从磁盘文件复制到网卡设备**中，而不需要经由应用程序之手 。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换 。 对 Linux操作系统而言，零拷贝技术依赖于底层的 `sendfile()` 方法实现 。 对应于 Java 语言，`FileChannal.transferTo()` 方法的底层实现就是 `sendfile()` 方法。单纯从概念上理解 “零拷贝”比较抽象，这里简单地介绍一下它 。 考虑这样一种常用的情形 ： 你需要将静态内容(类似图片、文件)展示给用户 。 这个情形就意味着需要先将静态内容从磁盘中复制出来放到一个内存 buf 中，然后将这个 buf 通过套接字（Socket）传输给用户，进而用户获得静态内容 。 这看起来再正常不过了，但实际上这是很低效的流程，我们把上面的这种情形抽象成下面的过程 ：

