# cpu伪共享问题

https://zhuanlan.zhihu.com/p/124974025

https://zhuanlan.zhihu.com/p/79777058



https://strikefreedom.top/cpu-caches-theory-and-application

![1_ZHX6kf5XWUjsqEunmwI0Bw](..\images\1_ZHX6kf5XWUjsqEunmwI0Bw.png)

在处理器的世界里，有一个很重要的概念叫**访问局部性 (locality of reference)**，当处理器访问某个特定的内存地址时，有很大的概率会发生下面的情况：

cpu在**不久的将来**回去访问相同的地址，**这叫时间局部性**

cpu会访问特定地址附近的内存ddizhi，**这叫空间局部性**

之所以会有 CPU 缓存，**时间局部性**是其中一个重要的原因。不过，我们到底应该怎么利用处理器的空间局部性呢？比起拷贝一个单独的内存地址到 CPU 缓存里，拷贝一个**缓存行** (**Cache Line**) 是更好的实现。一个缓存行是一个**连续的**内存段。



```powershell
查看系统L1 缓存行
$ sysctl -a | grep cacheline
hw.cachelinesize: 64
缓存大小
$ sysctl hw.l1dcachesize
hw.l1icachesize: 32768

处理器会拷贝一段连续的 64 字节的内存段到 L1 缓存里，而不是仅仅拷贝一个单独的变量。举个例子，当处理器要拷贝一个由 int64 类型组成 Go 的切片到 CPU 缓存里的时候，它会一起拷贝 8 个元素，而不是单单拷贝 1 个。
```



处理器是如何保持缓存的一致性的？如果两个缓存行共享了一些内存地址，处理器将会把他们标记成 `Shared` 状态。如果一个线程修改了其中一个 `Shared` 状态的缓存行，那么两个缓存行都会被标记成 `Modified` 。为了保证缓存一致性，需要引入在多核之间引入一种协调机制，而这种机制可能会导致应用程序的性能大幅度下降。这个问题就是**伪共享 (Fasle Sharing)**。



要真正理解伪共享，首先要了解 **MESI 协议及 RFO 请求**：

从前面的内容我们可以知道，每个核心都有自己私有的 L1、L2 缓存。那么多线程编程时， 另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据， 该怎么做呢？

有人说可以通过**第 2 个核直接访问第 1 个核的缓存行**，这是当然是可行的，但这种方法不够快。跨核访问需要通过 **Memory Controller** (内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 **Memory Controller** 的总线带宽是有限的，扛不住这么多数据传输。**所以，CPU 设计者们更偏向于另一种办法：如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次。**

那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？

下面将详细地解答以上问题。 首先我们需要谈到一个协议—— MESI 协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S 和 I 代表使用 MESI 协议时缓存行所处的四个状态：

```
1M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；
2E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；
3S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；
4I（无效，Invalid）：缓存行失效, 不能使用。


1初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。
2
3本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。
4
5本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）
6
7远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。
8
9远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。

```

**请记住，CPU 缓存的最小的处理单位永远是缓存行 (Cache Line)，所以当某个核心发送 RFO 消息请求把其他核心对应的缓存行设置成`Invalid` 从而使得 `var1` 缓存失效的同时，也会导致同在一个缓存行里的 `var2` 失效，反之亦然。**





**缓存一致性协议（**MESI)：缓存一致性协议也叫缓存锁定，缓存一致性协议会阻止两个以上CPU同时修改缓存了相同主存数据的缓存副本



1.当CPU A将主存中的x cache line读入缓存中时，此时X副本的状态为E独占。

2.当CPU B将主存中的X cache line读入缓存中时，AB同时嗅探总线，得知X cache line不止一个副本，此时X的状态变为S共享

3,当CPU A将CACHE A中的x cache line修改为1后，Cache A中的X cache line 的状态变为M修改，并发送消息给CPU B，CPU将X cache line的状态变为I无效

4.当CPU A确认所有CPU缓存中的**都提交了I无效状态**，将修改后的值刷新到主存中，此时主存中的X变为了1，此时Cache A中的x cache line变为E独享

5.当CPU B需要用到X，发出读取X指令，于是读取主存中的x，于是重复第二步







我们知道kernel地址空间是所有进程共享的，所以kernel空间的全局变量，任何进程都可以访问。假设有2个全局变量global_A和global_B(类型是long)，它们在内存上紧挨在一起，**假设cache line size是64Bytes**，并且global_A是cache line size对齐。所以global_A和global_B如果同时load到Cache中，一定是落在同一行cache line。就像下面这样。



     CPU内部也会有自己的缓存，内部的缓存单位是行，叫做缓存行。在多核环境下会出现CPU之间的内存同步问题（比如一个核加载了一份缓存，另外一个核也要用到同一份数据），如果每个核每次需要时都往内存中存取，这会带来比较大的性能损耗，这个问题一般是通过MESI协议来解决的。
    
    MESI协议中包含M、E、S、I四个状态，分别的意思是：
M(修改, Modified): 本地处理器已经修改缓存行, **即是脏行,** 它的内容与**内存中的内容不一样**. 并且此cache只有本地一个拷贝(专有).
E(专有, Exclusive): **缓存行内容和内存中的一样**, 而且其它处理器都没有这行数据
S(共享, Shared): 缓存行内容和内存中的一样, **有可能其它处理器也存在此缓存行的拷贝**
I(无效, Invalid): **缓存行失效, 不能使用**

```
初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。

本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。

本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）

远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。

远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。
```



  cpu在对缓存行进行了不同的操作后，在cpu缓存行中会记录缓存的不同状态。**当一个核要对共享的数据进行写操作时，需要给其他核发送RFO(REQUEST FOR OWNER)消息并把其他核的数据改成I态**。这是一种比较消耗性能的操作。
          cpu的伪共享问题本质是：几个在逻辑上并不包含在同一个内存单元内的数据，由于被cpu加载在同一个缓存行当中，当在多线程环境下，被不同的cpu执行，导致缓存行失效而引起的大量的缓存命中率降低。
          例如：当两个线程分别对一个数组中的两份数据进行写操作，每个线程操作不同index上的数据，看上去，两份数据之间是不存在同步问题的，但是，由于他们可能在同一个cpu缓存行当中，这就会使这一份缓存行出现大量的缓存失效，如前所述当一份线程更新时要给另一份线程发送RFO消息并把它的缓存失效掉。
          解决这个问题的一个办法是让这个数组中不同index的数据在不同的缓存行：因为缓存行的大小是64个字节，那我们只要让数组中没份数据的大小大于64个字节，就可以保证他们在不同的缓存行当中，就能避免这样的伪共享问题。
          比如一个类当中原本只有一个long类型的属性。这样这个类型的对象只占了16个字节（java对象头有8字节），如果这个类型被定义成一个长度为4的数组，这个数组的所有数据都可能在一个缓存行当中，就可能出现伪共享问题，那么这个时候，就可以采用补齐(padding)的办法，在这个类型中加上public long a,b,c,d,e,f,g;这六个无用的属性定义，使得这个类型的一个实例占用内存达到64字节，这样这个类型的伪共享问题就得到了解决，在多线程当中对这个类型的数组进行写操作就能避免伪共享问题。





理解该图的前置说明：

- 触发事件

**本地读取（Local read）：**本地cache读取本地cache数据

**本地写入（Local write）：**本地cache写入本地cache数据

**远端读取（Remote read）：**其他cache读取本地cache

**数据远端写入（Remote write）：**其他cache写入本地cache数据

- cache分类：

前提：所有的cache共同缓存了主内存中的某一条数据。

**本地cache**：指当前cpu的cache。
**触发cache**：触发读写事件的cache。
**其他cache**：指既除了以上两种之外的cache。
注意：本地的事件触发 本地cache和触发cache为相同。



- **M状态（修改）**

```text
触发本地读取:
    本地cache:M 
    触发cache:M
    其他cache:I

触发本地写入:
    本地cache:M 
    触发cache:M
    其他cache:I

触发远端读取:
    本地cache:M→E→S
    触发cache:I→S
    其他cache:I→S
    同步主内存后修改为E独享,同步触发、其他cache后本地、触发、其他cache修改为S共享

触发远端写入:
    本地cache:M→E→S→I
    触发cache:I→S→E→M
    其他cache:I→S→I
    同步和读取一样,同步完成后触发cache改为M，本地、其他cache改为I    
```

- **E状态（独享）**

```text
触发本地读取:
    本地cache:E
    触发cache:E
    其他cache:I

触发本地写入:
    本地cache:E→M
    触发cache:E→M
    其他cache:I
    本地cache变更为M,其他cache状态应当是I（无效）

触发远端读取:
    本地cache:E→S
    触发cache:I→S
    其他cache:I→S
    当其他cache要读取该数据时，其他、触发、本地cache都被设置为S(共享)

触发远端写入:
    本地cache:E→S→I
    触发cache:I→S→E→M
    其他cache:I→S→I
    当触发cache修改本地cache独享数据时时，将本地、触发、其他cache修改为S共享.然后触发cache修改为独享，
其他、本地cache修改为I（无效），触发cache再修改为M
```



- **I状态（无效）**

```text
触发本地读取:
    本地cache:I→S或者I→E
    触发cache:I→S或者I →E
    其他cache:E、M、I→S、I
    本地、触发cache将从I无效修改为S共享或者E独享，其他cache将从E、M、I 变为S或者I

触发本地写入:
    本地cache:I→S→E→M
    触发cache:I→S→E→M
    其他cache:M、E、S→S→I

触发远端读取:
    既然是本cache是I，其他cache操作与它无关

触发远端写入:
    既然是本cache是I，其他cache操作与它无关
```