### 锁



http://mysql.taobao.org/monthly/2017/12/02/

http://mysql.taobao.org/monthly/2016/01/01/

**http://mysql.taobao.org/monthly/2018/05/04/**

MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持**表级锁和行级锁**，MyISAM **只支持表级锁**。

https://blog.csdn.net/qq_40378034/article/details/90904573



**另一类表级的锁是MDL（metadata lock)。**MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，**保证读写的正确性**。你可以想象一下，如果一个查询正在遍历一个表中的数据，**而执行期间另一个线程对这个表结构做变更，删了一列**，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在MySQL **5.5版**本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；**当要对表做结构变更操作的时候**，加MDL**写锁**。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然MDL锁是**系统默认会加的**，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：**给一个小表加个字段，导致整个库挂了**。

你肯定知道，给一个表加字段，或者修改字段，或者加索引，**需要扫描全表的数据**。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。

<img src="..\images\7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg"  style="zoom:50%;" />

我们可以看到session A先启动，这时候会对表t加一个MDL**读锁**。由于session B需要的也是MDL**读锁**，因此可以正常执行。

之后session C会被blocked，是因为session A的MDL**读锁**还没有释放，而session C需要MDL**写锁**，因此只能被阻塞。

如果只有session C自己被阻塞还没什么关系，**但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞**。前面我们说了，所有**对表的增删改查操作都需要先申请MDL读锁**，就都被锁住，等于这个表现在完全不可读写了。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。

你现在应该知道了，**事务中**的MDL锁，在语句执行**开始时申请**，但是语句结束后并不会马上释放，而会等到整个**事务提交后再释放**。

基于上面的分析，我们来讨论一个问题，**如何安全地给小表加字段？**

首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，**在alter table语句里面设定等待时间**，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。





### 行锁

<img src="D:\gocode\read-code\images\51f501f718e420244b0a2ec2ce858710.jpg" style="zoom:43%;" />



假设字段id是表t的主键。

这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。

知道了这个答案，你一定知道了事务A持有的两个记录的行锁，**都是在commit的时候才释放的**。



也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，**而是要等到事务结束时才释放。这个就是两阶段锁协议**。

假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：

1. 从顾客A账户余额中扣除电影票价；
2. 给影院B的账户余额增加这张电影票价；
3. 记录一条交易日志。

也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？

试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。

**根据两阶段锁协议**，不论你怎样安排语句顺序，所有的操作需要的行锁都是在**事务提交的时候才释放的**。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。

好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。

如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？

这里，我就要说到死锁和死锁检测了。

# 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。

<img src="..\images\4d0eeec7b136371b79248a0aed005a52.jpg" style="zoom:50%;" />



这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

在InnoDB中，**innodb_lock_wait_timeout**的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。





















#### 如何处理死锁？

对待死锁常见的两种策略：

- **通过 innodblockwait_timeout 来设置超时时间**，一直等待直到超时；
- 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。(设置 innodbdeadlockdetect 设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。）

#### 如何查看死锁？

- 使用命令 show engine innodb status 查看最近的一次死锁。
- InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。

#### InnoDB 默认是如何对待死锁的？

InnoDB 默认是使用设置死锁时间来让死锁超时的策略，**默认 innodblockwait_timeout 设置的时长是 50s**。





#### 什么是共享锁？

共享锁又称**读锁 (read lock)**，是读取操作创建的锁。**其他用户可以并发读取数据**，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。（应该是无法拿到锁？）

#### 什么是排它锁？

排他锁 exclusive lock（也叫 writer lock）**又称写锁**。

若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作（**快照读**？），需等待其释放。

排它锁是**悲观锁的一种实现**，在上面悲观锁也介绍过。

若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。







#### 如何实现表锁



MySQL 里标记锁有两种：表级锁、**元数据锁（meta data lock）简称 **MDL**。表锁的语法是 lock tables t read/write。

可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

MDL：不需要显式使用，在访问一个表的时候会被自动加上。

MDL 的作用：保证读写的正确性。

**在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。**

**读锁之间不互斥，读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。**

**MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。**





#### InnoDB 存储引擎有几种锁算法？

- Record Lock — 单个行记录上的锁；
- Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；
- Next-Key Lock — 锁定一个范围，包括记录本身。（record lock+gap lock）







#### 2、innoDB的间隙锁/Next-Key Lock

##### 2-1、明确前提条件

- innoDB的间隙锁只存在于 RR 隔离级别

所以希望禁用间隙锁，提升系统性能的时候，可以考虑将隔离级别降为 RC。

##### 2-2、间隙锁/Next-Key Lock

**间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生**：

- 防止间隙内有新数据被插入。
- 防止已存在的数据，更新成间隙内的数据。

innoDB默认的隔离级别是可重复读(Repeatable Read)，并且会以Next-Key Lock的方式对数据行进行加锁。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，**会首先对索引记录加上行锁（Record Lock）**，**再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录**。

当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围。



##### 2-3、何时使用行锁，何时产生间隙锁

对上一节的最后一句做个扩展说明。

1. 只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。
2. 只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在（试图锁住不存在的数据）时，会产生 Next-Key Lock。
3. 使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。
4. 同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。









#### MDL锁与实现

MySQL5.5版本引入了MDL锁（metadata lock），用于解决或者保证DDL操作与DML操作之间的一致性。例如下面的这种情形：

| 会话1             | 会话2          |
| ----------------- | -------------- |
| BEGIN;            |                |
| SELECT * FROM XXX |                |
|                   | DROP TABLE XXX |
| SELECT * FROM XXX |                |



若没有MDL锁的保护，则事务2可以直接执行DDL操作，并且导致事务1出错，5.1版本即是如此。5.5版本加入MDL锁就在于保护这种情况的发生，**由于事务1开启了查询，那么获得了MDL锁**，锁的模式为SHARED_READ，**事务2要执行DDL，则需获得EXCLUSIVE锁**，两者互斥，所以事务2需要等待。