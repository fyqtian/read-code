### 锁



http://mysql.taobao.org/monthly/2017/12/02/

http://mysql.taobao.org/monthly/2016/01/01/

**http://mysql.taobao.org/monthly/2018/05/04/**

MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持**表级锁和行级锁**，MyISAM **只支持表级锁**。









#### 如何处理死锁？

对待死锁常见的两种策略：

- **通过 innodblockwait_timeout 来设置超时时间**，一直等待直到超时；
- 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。(设置 innodbdeadlockdetect 设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。）

#### 如何查看死锁？

- 使用命令 show engine innodb status 查看最近的一次死锁。
- InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。

#### InnoDB 默认是如何对待死锁的？

InnoDB 默认是使用设置死锁时间来让死锁超时的策略，**默认 innodblockwait_timeout 设置的时长是 50s**。





#### 什么是共享锁？

共享锁又称**读锁 (read lock)**，是读取操作创建的锁。**其他用户可以并发读取数据**，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。（应该是无法拿到锁？）

#### 什么是排它锁？

排他锁 exclusive lock（也叫 writer lock）**又称写锁**。

若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作（**快照读**？），需等待其释放。

排它锁是**悲观锁的一种实现**，在上面悲观锁也介绍过。

若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。







#### 如何实现表锁



MySQL 里标记锁有两种：表级锁、**元数据锁（meta data lock）简称 **MDL**。表锁的语法是 lock tables t read/write。

可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

MDL：不需要显式使用，在访问一个表的时候会被自动加上。

MDL 的作用：保证读写的正确性。

**在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。**

**读锁之间不互斥，读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。**

**MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。**





#### InnoDB 存储引擎有几种锁算法？

- Record Lock — 单个行记录上的锁；
- Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；
- Next-Key Lock — 锁定一个范围，包括记录本身。（record lock+gap lock）







#### 2、innoDB的间隙锁/Next-Key Lock

##### 2-1、明确前提条件

- innoDB的间隙锁只存在于 RR 隔离级别

所以希望禁用间隙锁，提升系统性能的时候，可以考虑将隔离级别降为 RC。

##### 2-2、间隙锁/Next-Key Lock

**间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生**：

- 防止间隙内有新数据被插入。
- 防止已存在的数据，更新成间隙内的数据。

innoDB默认的隔离级别是可重复读(Repeatable Read)，并且会以Next-Key Lock的方式对数据行进行加锁。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，**会首先对索引记录加上行锁（Record Lock）**，**再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录**。

当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围。



##### 2-3、何时使用行锁，何时产生间隙锁

对上一节的最后一句做个扩展说明。

1. 只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。
2. 只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在（试图锁住不存在的数据）时，会产生 Next-Key Lock。
3. 使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。
4. 同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。









#### MDL锁与实现

MySQL5.5版本引入了MDL锁（metadata lock），用于解决或者保证DDL操作与DML操作之间的一致性。例如下面的这种情形：

| 会话1             | 会话2          |
| ----------------- | -------------- |
| BEGIN;            |                |
| SELECT * FROM XXX |                |
|                   | DROP TABLE XXX |
| SELECT * FROM XXX |                |



若没有MDL锁的保护，则事务2可以直接执行DDL操作，并且导致事务1出错，5.1版本即是如此。5.5版本加入MDL锁就在于保护这种情况的发生，**由于事务1开启了查询，那么获得了MDL锁**，锁的模式为SHARED_READ，**事务2要执行DDL，则需获得EXCLUSIVE锁**，两者互斥，所以事务2需要等待。