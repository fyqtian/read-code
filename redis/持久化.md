### 持久化

### key过期



**定期删除**

redis 会将**每个设置了过期时间**的 key 放入到一个**独立的字典中**，以后会定期遍历这个字典来删除到期的 key。

Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

1.从过期字典中随机 20 个 key；

2.删除这 20 个 key 中已经过期的 key；

3.如果过期的 key 比率超过 1/4，那就重复步骤 1；

redis默认是每隔 100ms就随机抽取一**些设置了过期时间的key**，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。



### **惰性删除**

所谓惰性策略就是在客户端**访问这个key的时候**，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时,如果发现key过期了,就立即进行删除,不返回任何东西.

**总结：定期删除是集中处理，惰性删除是零散处理。**





过期策略通常有以下三种：

- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。**该策略可以立即清除过期的数据**，对内存很友好；**但是会占用大量的CPU资源去处理过期的数据**，从而影响缓存的响应时间和吞吐量。
- 惰性过期：**只有当访问一个key时，才会判断该key是否已过期，过期则清除**。该策略可以最大化地节省CPU资源，**却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存**。
- 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
  (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

Redis中同时使用了**惰性过期和定期过期两种过期策略**。

### 我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?

除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

1. 定时去清理过期的缓存；
2. 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。





### Redis的内存淘汰策略有哪些

https://zhuanlan.zhihu.com/p/105587132?utm_source=qq

https://www.cnblogs.com/alsf/p/9399011.html

#### **为什么需要淘汰策略**

有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，**因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除**，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。



Redis的内存淘汰策略是指在Redis的用于**缓存的内存不足时**，怎么处理需要新写入且需要申请额外空间的数据。

全局的键空间选择性移除

- noeviction：当内存使用超过配置的时候**会返回错误，不会驱逐任何键**。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。



设置过期时间的键空间选择性移除

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。





### **RDB持久化**



**tip：两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。**

https://www.jianshu.com/p/d3ba7b8ad964

https://blog.csdn.net/zmflying8177/article/details/103500645

https://www.cnblogs.com/ybyn/p/14157568.html()

手动触发分别对应save和bgsave命令

save命令：**阻塞当前Redis服务器**，直到RDB过程完成为止，**对于内存 比较大的实例会造成长时间阻塞**，线上环境不建议使用

bgsave命令：**Redis进程执行fork操作创建子进程**，**RDB持久化过程由子 进程负责**，完成后自动结束。阻塞只发生在fork阶段，一般时间很短**（过程中发生的变化缓存等bgsave后同步）**

![17993869-ec903b30431cb304](..\images\17993869-ec903b30431cb304.webp)

1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进 程，如RDB/AOF子进程，如果存在bgsave命令直接返回。

2）父进程执行fork操作创建子进程**，fork操作过程中父进程会阻塞**，通 过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒

3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。

4）**子进程创建RDB文件，根据父进程内存生成临时快照文件**，**完成后 对原有文件进行原子替换**。执行lastsave命令可以获取最后一次生成RDB的 时间，对应info统计的rdb_last_save_time选项。

5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的rdb_*相关选项**。**



**Redis的cow copy on write**
Redis创建子进程以后，根本不进行数据的copy，**主进程与子线程是共享数据的**。主进程继续对外提供读写服务。
虽然不copy数据，但是kernel会把**主进程中的所有内存页的权限都设为read-only**，主进程和子进程访问数据的指针都指向同一内存地址。
主进程发生写操作时，**因为权限已经设置为read-only了**，所以会触发页异常中断（page-fault）。在中断处理中，需要被写入的内存页面会复制一份，复制出来的旧数据交给子进程使用，然后主进程该干啥就干啥。

也就是说，**在进行IO操作写盘的过程中（on write），对于没有改变的数据，主进程和子进程资源共享；**只有在出现了需要变更的数据时（写脏的数据），才进行copy操作。

在最理想的情况下，也就是生成RDB文件的过程中，一直没有写操作的话，就根本不会发生内存的额外占用。

当然，仍然需要合理配置Linux的内存分配策略。避免在写操作过于集中时，发生因为物理内存不足导致fork失败的情况。


# RDB的优缺点 

#### RDB的优点： 

RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。

·Redis加载RDB恢复数据远远快于AOF的方式。

**缺点**

- RDB方式实时性不够，无法做到秒级的持久化；
- 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
- RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
- 版本兼容RDB文件问题；



# AOF持久化

AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式



#### 使用AOF

开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名 通过appendfilename配置设置，默认文件名是appendonly.aof。保存路径同 RDB持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）



<img src="D:\gocode\read-code\images\17993869-798dae4b8f2b12bd.webp" alt="17993869-798dae4b8f2b12bd" style="zoom:50%;" />

- append
  **aof文件只记录写命令**，不记录读命令，当服务端接收到写命令后，redis会将命令写入到**aof缓冲区中**，之所以写入缓冲区而不直接写入aof文件中是因为**如果每次都将命令直接写入到文件中，那么redis的性能将完全取决于硬盘的读写能力**，这与redis性能至上的理念不符，另外，写入缓冲区中也便于使用不同的同步策略。

- sync
  文件同步，即将aof缓冲区中的命令同步到aof文件中，redis提供三种策略以供选择，由参数**appendfsync**控制，三种策略分别是：

- > always: 表示命令append到缓冲区以后调用系统fsync操作同步到aof文件中，fsync操作完成后主线程返回；

  > no： 表示命令写入aof缓冲区后调用操作系统write操作，不对aof文件做fsync同步，同步到硬盘操作由操作系统负责，通常同步周期最长30秒；

  > everysec： 表示命令写入aof缓冲区后调用操作系统write操作，write操作完成后主线程返回，由专门的线程每秒去进行fsync同步文件操作

  **默认使用everysec**，兼顾性能和安全性，很显然，使用always时每次都要等同步完成后才能返回，这个性能是很低的；同理使用no时，虽然不用每次都同步aof文件，但是同步操作周期不可控，数据安全性得不到保障，因此还是使用默认的everysec兼顾安全性和性能，每一秒同步一次，也就是在突发状况下最多丢失1秒的数据。

  - 重写（rewrite）

  **随着写命令越来越多，aof文件的体积也越来越大，此时就需要重写机制来按照特定的机制清除或者合并命令从而达到减小文件体积，便于redis重启加载的目的。**



#### 开启混合持久化

redis4.0开始支持该模式
为了解决的问题：
redis在重启时通常是加载AOF文件，但加载速度忙
因为RDB数据不完整，所以加载AOF
开启方式： aof-use-rdb-preamble true
开启后，AOF在重写时会直接读取RDB中的内容
运行过程：
通过bgrwriteaof完成，不同的是当开启混合持久化后，
1 子进程会把内存中的数据以RDB的方式写入aof中，
2 把重写缓冲区中的增量命令以AOF方式写入到文件
3 将含有RDB个数和AOF格数的AOF数据覆盖旧的AOF文件
新的AOF文件中，一部分数据来自RDB文件，一部分来自Redis运行过程时的增量数据











## 重写机制

### 重写规则

- **进程内已经过期的数据不再写入文件**；
- 只保存最终数据的写入命令，如set a 1, set a 2, set a 3，此时只保留最终的set a 3;
- 多条写命令合并为一条命令，如lpush list 1, lpush list 2, lpush list 3合并为lpush list 1,2,3，同时为了防止单条命令过大，对于list、set、zset、hash等以64个元素为界限拆分为多条命令；



### 触发

- 手动触发
  手动执行`bgrewriteaof`命令即可触发aof重写
- 自动触发
  自动触发与redis.conf中的`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`配置有关，默认配置如下：



```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

auto-aof-rewrite-min-size: 表示触发aof重写时aof文件的最小体积，默认64m
auto-aof-rewrite-percentage： 表示当前aof文件空间和上一次重写后aof文件空间的比值，默认是aof文件体积翻倍时触发重写

<img src="..\images\2159277-20201218230022086-946569922.png" alt="2159277-20201218230022086-946569922" style="zoom: 50%;" />

1. 手动或者自动触发文件重写后主进程需要先判断当前**是否有子进程存在**，如果存在则直接返回，不存在则fork子进程；
2. fork操作完成后，主进程即可响应其他命令，在子进程生成新的aof文件过程中，主进程仍然维持原来的流程以保证原有aof机制的正确性；
3. **在子进程生成新的aof文件过程中主进程执行的新命令同时会被写入到aof重写缓冲区中**，当新aof文件生成后再将这一部分命令写入到新aof文件中，防止数据丢失；
4. 子进程根据内存快照，根据重写规则生成新的aof文件，每次批量写入硬盘数据量由配置`aof-rewrite-incremental-fsync`控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞；
5. 父进程把aof重写缓冲区的数据写入到新的aof文件中；
6. 使用新aof文件替换旧的aof文件并发送信号给主进程表示重写完成。

### 优点

- 数据安全性较高，每隔1秒同步一次数据到aof文件，最多丢失1秒数据；
- aof文件相比rdb文件可读性较高，便于灾难恢复；

### 缺点

- 虽然经过文件重写，但是aof文件的体积仍然比rdb文件体积大了很多，不便于传输且数据恢复速度也较慢
- aof的恢复速度要比rdb的恢复速度慢