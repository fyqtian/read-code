### 三次握手

https://juejin.cn/post/6844903987313901575

https://draveness.me/whys-the-design-tcp-three-way-handshake/

https://www.zhihu.com/question/24853633

https://www.zhihu.com/question/24853633



**对于建链接的3次握手，**主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）





TCP看似复杂，其实可以归纳为以下5种报文： 

**（1）**   **SYN**

**（2）**   **Data** **（唯一携带用户数据）**

**（3）**   **FIN**

**（4）**   **Reset**

**（5）**   **ACK**

其中1、2、3分别为**建立连接、数据传输、断开连接**，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。**如果对方在超时时间内不确认，发送方会一直重传**，直到对方确认为止、或到达重传上限次数而Reset连接。

 4、5 为**重置连接报文、确认ACK报文**，这两种报文对方接收到要ACK确认吧？**不需要！自然发送方也不会重传这2种类型的报文**。

**为何Reset报文不需要ACK确认?**

因为发送Reset报文的一端，在发送完这个报文之后，**和该TCP Session有关的内存结构体瞬间全部释放**，无论对方收到或没有收到，关系并不大。

如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。

如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。

**为何ACK报文不需要ACK确认?**

这里的ACK报文**，是指没有携带任何数据的裸ACK报文**，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。







- **三次握手才可以阻止重复历史连接的初始化（主要原因）**
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费



*The principle reason for the three-way handshake is to **prevent old duplicate connection initiations from causing confusion.***

简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

如果 TCP 建立连接只**能通信两次**，**那么接收方只能选择接受或者拒绝发送方发起的请求**，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。



所以，TCP 选择使用三次握手来建立连接并在连接引入了 `RST` 这一控制消息，接收方当收到请求时会将发送方发来的 `SEQ+1` 发送给对方，这时由发送方来判断当前连接是否是历史连接：

- **如果当前连接是历史连接**，即 `SEQ` 过期或者超时，那么发送方就会直接发送 `RST` 控制消息中止这一次连接；
- **如果当前连接不是历史连接**，那么发送方就会发送 `ACK` 控制消息，通信双方就会成功建立连接；

使用三次握手和 `RST` 控制消息将是否建立连接的最终控制权**交给了发送方**，**因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的**，这也是 TCP 使用三次握手建立连接的最主要原因





网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？

客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

- **一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端**；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，**客户端因有足够的上下文来判断当前连接是否是历史连接**

如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；

所以， TCP 使用三次握手建立连接的最主要原因是**防止历史连接初始化了连接。**



**原因三**：避免资源浪费

如果只有「两次握手」，当客户端的 `SYN` 请求连接在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认信号，所以每收到一个 `SYN` 就只能先主动建立一个连接，这会造成什么情况呢？







The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.

文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：**用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。**



**TCP可靠传输的精髓**：TCP连接的一方A，由操作系统动态随机选取一个**32位长的序列号（Initial Sequence Number）**，

假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，**让B有一个思想准备**，**什么样编号的数据是合法的**，什么编号是非法的，比如编号900就是非法的，**同时B还可以对A每一个编号的字节数据进行确认**。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。



**四次握手的过程：**

A 发送同步信号**SYN** + **A's Initial sequence number**

B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 B's ACK sequence number

B发送同步信号**SYN** + **B's Initial sequence number**

A确认收到B的同步信号，并记录 B's ISN 到本地，命名 **A's ACK sequence number**

**很显然B的两个操作**，**只需要三次握手，**可以提高连接的速度与效率。



#### 二次握手

A 发送同步信号**SYN** + **A's Initial sequence number**

B发送同步信号SYN+B's Initial sequence number + B's ACK sequence number

这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，**A和B就B的初始序列号将无法达成一致。**（那A第一次发送数据的时候B 是否能校验）

于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，**所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号**。

有童鞋会说，如果A发给B的确认丢了，该如何？

A会超时重传这个ACK吗？**（没有ack的ack）**不会！**TCP不会为没有数据的ACK超时重传**

那该如何是好？**B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**



------

**第一个包，即A发给B的SYN 中途被丢，没有到达B**

A会周期性超时重传，直到收到B的确认

**第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A**

B会周期性超时重传，直到收到A的确认

**第三个包，即A发给B的ACK 中途被丢，没有到达B**

A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：



























在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”**。在另一部经典的《计算机网络》一书中讲“三次握手”**的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题**。

谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。**本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段**，同意建立连接。**假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了**。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”



这个问题的本质是**, 信道不可靠**, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, **三次通信是理论上的最小值.** 所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。

